<template>
  <q-layout v-if="gameExists" class="non-selectable" view="lHr LpR lFr">
    <q-header elevated class="bg-ui">
      <q-toolbar class="q-pa-none">
        <q-btn
          icon="moves"
          @click="showPTN = !showPTN"
          :color="showPTN ? 'primary' : ''"
          stretch
          flat
        />
        <q-toolbar-title class="q-pa-none">
          <GameSelector ref="gameSelector">
            <q-icon
              v-if="isLocal || player"
              name="edit"
              @click.stop="edit"
              class="q-field__focusable-action q-mr-sm"
            />
          </GameSelector>
        </q-toolbar-title>
        <q-btn
          :icon="
            textTab === 'notes' ? (notifyNotes ? 'notes' : 'notes_off') : 'chat'
          "
          @click.left="showText = !showText"
          @click.right.prevent="notifyNotes = !notifyNotes"
          :color="showText ? 'primary' : ''"
          stretch
          flat
        />
      </q-toolbar>
    </q-header>

    <q-page-container
      class="bg-bg"
      v-shortkey="hotkeys.UI"
      @shortkey="
        if (!disabledOptions.includes($event.srcKey))
          $store.dispatch('ui/TOGGLE_UI', $event.srcKey);
      "
    >
      <q-page
        v-shortkey="hotkeys.ACTIONS"
        @shortkey="shortkeyAction"
        class="overflow-hidden"
      >
        <div
          class="column absolute-fit"
          v-shortkey="hotkeys.MISC"
          @shortkey="miscShortkey"
        >
          <Board ref="board" class="col-grow" />
        </div>
        <q-page-sticky position="top-right" :offset="[6, 6]">
          <BoardToggles
            v-if="$route.name !== 'embed' && !isGamesTableShowing"
          />
        </q-page-sticky>
        <q-page-sticky position="bottom-right" :offset="[18, 18]">
          <Menu @input="menuAction" @click.right.prevent="switchGame" />
        </q-page-sticky>
        <q-page-sticky position="bottom" :offset="[0, 0]">
          <CurrentMove style="margin-right: 65px" />
        </q-page-sticky>
      </q-page>
    </q-page-container>

    <q-drawer
      id="left-drawer"
      v-model="showPTN"
      side="left"
      :breakpoint="showText ? doubleWidth : singleWidth"
      :no-swipe-open="!Platform.is.mobile"
      :no-swipe-close="!Platform.is.mobile"
      persistent
    >
      <div class="absolute-fit column">
        <PTN-Tools ref="tools">
          <ShareButton ref="shareButton" :title="$t('Share')" />
        </PTN-Tools>
        <div class="col-grow relative-position">
          <PTN class="absolute-fit" />
        </div>
        <q-toolbar class="footer-toolbar bg-ui q-pa-none">
          <UndoButtons spread stretch flat unelevated />
          <EvalButtons class="full-width" spread stretch flat unelevated />
        </q-toolbar>
      </div>
      <div class="gt-xs absolute-fit inset-shadow no-pointer-events" />
    </q-drawer>

    <q-drawer
      id="right-drawer"
      v-model="showText"
      side="right"
      :breakpoint="showPTN ? doubleWidth : singleWidth"
      :no-swipe-open="!Platform.is.mobile"
      :no-swipe-close="!Platform.is.mobile"
      persistent
    >
      <div class="absolute-fit column">
        <q-tabs
          v-if="hasChat"
          class="bg-ui text-weight-medium"
          :value="textTab"
          @input="showTextTab"
          active-color="primary"
          indicator-color="primary"
          align="justify"
        >
          <q-tab name="notes">{{ $t("Notes") }}</q-tab>
          <q-tab name="chat">{{ $t("Chat") }}</q-tab>
        </q-tabs>
        <q-toolbar
          v-else
          class="bg-ui text-weight-medium justify-center text-uppercase"
        >
          {{ $t("Notes") }}
        </q-toolbar>
        <q-tab-panels class="col-grow bg-transparent" :value="textTab" animated>
          <q-tab-panel name="notes">
            <Notes ref="notes" class="fit" recess />
          </q-tab-panel>
          <q-tab-panel v-if="hasChat" name="chat">
            <Chat ref="chat" class="fit" recess />
          </q-tab-panel>
        </q-tab-panels>
      </div>
      <div class="gt-xs absolute-fit inset-shadow no-pointer-events" />
    </q-drawer>

    <q-footer class="bg-ui">
      <Scrubber />
      <q-toolbar
        v-show="isEditingTPS || $store.state.ui.showControls"
        class="footer-toolbar q-pa-sm"
      >
        <PieceSelector
          v-if="isEditingTPS"
          class="justify-around items-center"
          style="width: 100%; max-width: 500px; margin: 0 auto"
          v-model="selectedPiece"
        >
          <q-input
            type="number"
            v-model="firstMoveNumber"
            :label="$t('Move')"
            :min="minFirstMoveNumber"
            :max="999"
            filled
            dense
          />
          <q-btn :label="$t('Cancel')" @click="resetTPS" color="primary" flat />
          <q-btn :label="$t('OK')" @click="saveTPS" color="primary" flat />
        </PieceSelector>
        <PlayControls v-else />
      </q-toolbar>
    </q-footer>

    <router-view ref="dialog" no-route-dismiss />

    <ErrorNotifications :errors="errors" />
    <GameNotifications />
    <NoteNotifications />
  </q-layout>
  <q-dialog v-else :value="true" persistent>No Game</q-dialog>
</template>

<script>
// Essentials:
import Board from "../components/board/Board";
import CurrentMove from "../components/board/CurrentMove";
import PTN from "../components/drawers/PTN";
import Notes from "../components/drawers/Notes";

// Notifications:
import ErrorNotifications from "../components/notify/ErrorNotifications";
import GameNotifications from "../components/notify/GameNotifications";
import NoteNotifications from "../components/notify/NoteNotifications";

// Controls:
import PlayControls from "../components/controls/PlayControls";
import Scrubber from "../components/controls/Scrubber";
import PTNTools from "../components/controls/PTNTools";
import UndoButtons from "../components/controls/UndoButtons";
import EvalButtons from "../components/controls/EvalButtons";
import BoardToggles from "../components/controls/BoardToggles";
import ShareButton from "../components/controls/ShareButton";

// Excluded from Embed layout:
// import onlineStore from "../store/online";
import GameSelector from "../components/controls/GameSelector";
import PieceSelector from "../components/controls/PieceSelector";
import Menu from "../components/controls/Menu";
import Chat from "../components/drawers/Chat";

import Game from "../Game";
import { HOTKEYS } from "../keymap";

import { Platform } from "quasar";

export default {
  components: {
    Board,
    CurrentMove,
    PTN,
    Notes,
    ErrorNotifications,
    GameNotifications,
    NoteNotifications,
    PlayControls,
    Scrubber,
    PTNTools,
    UndoButtons,
    EvalButtons,
    BoardToggles,
    ShareButton,
    Chat,
    GameSelector,
    PieceSelector,
    Menu,
  },
  props: ["ptn", "state", "name", "gameID"],
  data() {
    return {
      Platform,
      errors: [],
      hotkeys: HOTKEYS,
      doubleWidth: 1025,
      singleWidth: this.$q.screen.sizes.sm,
    };
  },
  computed: {
    gameExists() {
      return Boolean(this.$game);
    },
    isLocal() {
      return this.$game ? this.$game.isLocal : false;
    },
    showPTN: {
      get() {
        return this.$store.state.ui.showPTN;
      },
      set(value) {
        this.$store.dispatch("ui/SET_UI", ["showPTN", value]);
      },
    },
    showText: {
      get() {
        return this.$store.state.ui.showText;
      },
      set(value) {
        this.$store.dispatch("ui/SET_UI", ["showText", value]);
      },
    },
    hasChat() {
      return this.$game ? this.$game.hasChat : false;
    },
    textTab: {
      get() {
        return this.hasChat ? this.$store.state.ui.textTab : "notes";
      },
      set(value) {
        this.$store.dispatch("ui/SET_UI", ["textTab", value]);
      },
    },
    notifyNotes: {
      get() {
        return this.$store.state.ui.notifyNotes;
      },
      set(value) {
        this.$store.dispatch("ui/SET_UI", ["notifyNotes", value]);
      },
    },
    isEditingTPS: {
      get() {
        return this.$store.state.ui.isEditingTPS;
      },
      set(value) {
        this.$store.dispatch("ui/SET_UI", ["isEditingTPS", value]);
        if (!value) {
          this.editingTPS = "";
        }
      },
    },
    selectedPiece: {
      get() {
        return this.$store.state.ui.selectedPiece;
      },
      set(value) {
        this.$store.dispatch("ui/SET_UI", ["selectedPiece", value]);
        this.editingTPS = this.$game.board._getTPS(
          this.selectedPiece.color,
          this.firstMoveNumber
        );
      },
    },
    minFirstMoveNumber() {
      const min1 =
        this.$store.state.game.board.piecesPlayed[1].total +
        this.$game.board.squares.reduce(
          (total, row) =>
            row.reduce(
              (total, square) =>
                square.pieces.length
                  ? total +
                    square.pieces.slice(1).filter((piece) => piece[0] === "1")
                      .length
                  : total,
              total
            ),
          0
        );
      const min2 =
        this.$store.state.game.board.piecesPlayed[2].total +
        Object.values(this.$store.state.game.board.squares).reduce(
          (total, square) =>
            square.pieces.length
              ? total +
                square.pieces.slice(1).filter((piece) => piece[0] === "2")
                  .length
              : total,
          0
        );
      return Math.max(min1, min2) + 1 * (min1 <= min2);
    },
    firstMoveNumber: {
      get() {
        return this.$store.state.ui.firstMoveNumber;
      },
      set(value) {
        this.$store.dispatch("ui/SET_UI", ["firstMoveNumber", 1 * value]);
        this.editingTPS = this.$game.board._getTPS(
          this.selectedPiece.color,
          this.firstMoveNumber
        );
      },
    },
    editingTPS: {
      get() {
        return this.$store.state.ui.editingTPS;
      },
      set(value) {
        this.$store.dispatch("ui/SET_UI", ["editingTPS", value]);
      },
    },
    disabledOptions() {
      return this.$store.getters["game/disabledOptions"];
    },
    isGamesTableShowing() {
      return (
        this.$route.name === "add" &&
        this.$route.params.tab === "load" &&
        this.$route.params.online
      );
    },
    games() {
      return this.$store.state.game.list;
    },
    user() {
      return null;
      // return this.$store.state.online.user;
    },
    player() {
      return this.user ? this.$game.getPlayerFromUID(this.user.uid) : 0;
    },
    isAnonymous() {
      return !this.user || this.user.isAnonymous;
    },
  },
  methods: {
    newGame() {
      const game = new Game({
        player1: this.$store.state.ui.player1,
        player2: this.$store.state.ui.player2,
        tags: { size: this.$store.state.ui.size },
      });
      return game;
    },
    async getGame() {
      let game;
      this.errors = [];

      const _handleError = (error) => {
        const name = game ? game.name : "";
        game = this.newGame();
        if (name) {
          game.name = name;
        }
        if (this.$te(`error["${error.message}"]`)) {
          this.errors.push(this.$t(`error["${error.message}"]`));
        } else {
          console.error(error);
        }
      };

      const _loadPrevious = () => {
        if (this.$store.state.game.list && this.$store.state.game.list.length) {
          try {
            game = this.$store.state.game.list[0];
            game = new Game(game);
            if (
              this.$store.state.ui.isEditingTPS &&
              this.$store.state.ui.editingTPS
            ) {
              this.$store.dispatch(
                "game/DO_TPS",
                this.$store.state.ui.editingTPS
              );
            }
          } catch (error) {
            _handleError(error);
          }
        }
      };

      if (this.ptn) {
        try {
          // Add game from URL
          let name = this.name;
          if (!this.name) {
            // If name isn't provided, parse the game to get a name
            game = new Game({ ptn: this.ptn });
            name = game.name;
          }
          const index = this.$store.state.game.list.findIndex(
            (g) => g.name === name
          );
          if (index < 0 || this.$store.state.ui.openDuplicate !== "replace") {
            // Open as a new game
            if (!game) {
              // If it hasn't been parsed yet, do it now
              game = new Game({ ptn: this.ptn, name });
            }
            if (game) {
              this.$store.dispatch("game/ADD_GAME", game);
              this.$router.replace("/");
            }
          } else {
            // Replace an existing game
            if (!game) {
              // If it hasn't been parsed yet, do it now
              game = new Game({ ptn: this.ptn, name });
            }
            game = await this.$store.dispatch("game/REPLACE_GAME", {
              index,
              ptn: this.ptn,
              gameState: this.state,
            });
            this.$router.replace("/");
          }
        } catch (error) {
          _handleError(error);
          _loadPrevious();
        }
      } else {
        _loadPrevious();
      }
      if (!game) {
        game = this.newGame();
      }
      game.warnings.forEach((warning) =>
        this.$store.dispatch("ui/NOTIFY_WARNING", warning)
      );

      if (process.env.DEV) {
        window.main = this;
        window.game = game;
      }
      this.$store.dispatch("game/SET_GAME", game);

      if (
        this.$store.state.ui.isEditingTPS &&
        this.$store.state.ui.editingTPS
      ) {
        this.$store.dispatch("game/DO_TPS", this.$store.state.ui.editingTPS);
      }
    },
    undo() {
      return this.$store.dispatch("game/UNDO");
    },
    redo() {
      return this.$store.dispatch("game/REDO");
    },
    resetTPS() {
      this.$store.dispatch("game/RESET_TPS");
    },
    saveTPS() {
      this.$store.dispatch("game/SAVE_TPS", this.editingTPS);
    },
    menuAction(action) {
      switch (action) {
        case "help":
          this.$router.push({ name: "help" });
          break;
        case "account":
          if (this.isAnonymous) {
            this.$router.push({ name: "login" });
          } else {
            this.$router.push({ name: "account" });
          }
          break;
        case "settings":
          this.$router.push({ name: "preferences" });
          break;
        case "share":
          this.share();
          break;
        case "add":
          this.$router.push({ name: "add", params: { tab: "new" } });
          break;
      }
    },
    shortkeyAction(event) {
      this.$store.dispatch(event.srcKey);
    },
    miscShortkey({ srcKey }) {
      switch (srcKey) {
        case "editGame":
          if (this.$route.name !== "info-edit") {
            this.$router.push({ name: "info-edit" });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "editPTN":
          if (this.$route.name !== "edit") {
            this.$router.push({ name: "edit" });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "embedGame":
          if (this.$route.name !== "embed") {
            this.$router.push({ name: "embed" });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "sharePNG":
          if (this.$route.name !== "png") {
            this.$router.push({ name: "png" });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "focusText":
          this.showText = true;
          this.$refs[
            this.hasChat && this.textTab === "chat" ? "chat" : "notes"
          ].$refs.input.focus();
          break;
        case "focusGame":
          this.$refs.gameSelector.$refs.select.showPopup();
          break;
        case "previousGame":
          if (this.$store.state.game.list.length > 1) {
            this.$refs.gameSelector.select(1);
          }
          break;
        case "toggleText":
          if (this.hasChat) {
            this.textTab = this.textTab === "notes" ? "chat" : "notes";
          }
          break;
        case "help":
          if (this.$route.name !== "help") {
            this.$router.push({
              name: "help",
              params: { section: "usage" },
            });
          } else if (this.$route.params.section !== "usage") {
            this.$router.replace({
              name: "help",
              params: { section: "usage" },
            });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "account":
          if (this.isAnonymous) {
            if (this.$route.name !== "login") {
              this.$router.push({ name: "login" });
            } else {
              this.$refs.dialog.$children[0].hide();
            }
          } else {
            if (this.$route.name !== "account") {
              this.$router.push({ name: "account" });
            } else {
              this.$refs.dialog.$children[0].hide();
            }
          }
          break;
        case "hotkeys":
          if (this.$route.name !== "help") {
            this.$router.push({
              name: "help",
              params: { section: "hotkeys" },
            });
          } else if (this.$route.params.section !== "hotkeys") {
            this.$router.replace({
              name: "help",
              params: { section: "hotkeys" },
            });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "loadGame":
          if (this.$route.name !== "add") {
            this.$router.push({
              name: "add",
              params: { tab: "load" },
            });
          } else if (this.$route.params.tab !== "load") {
            this.$router.replace({
              name: "add",
              params: { tab: "load" },
            });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "loadOnlineGame":
          if (this.$route.name !== "add") {
            this.$router.push({
              name: "add",
              params: { tab: "load", online: "online" },
            });
          } else if (
            this.$route.params.tab !== "load" ||
            !this.$route.params.online
          ) {
            this.$router.replace({
              name: "add",
              params: { tab: "load", online: "online" },
            });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "newGame":
          if (this.$route.name !== "add") {
            this.$router.push({
              name: "add",
              params: { tab: "new" },
            });
          } else if (this.$route.params.tab !== "new") {
            this.$router.replace({
              name: "add",
              params: { tab: "new" },
            });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "online":
          if (this.$route.name !== "online") {
            this.$router.push({ name: "online" });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "preferences":
          if (this.$route.name !== "preferences") {
            this.$router.push({ name: "preferences" });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "theme":
          if (this.$route.name !== "theme") {
            this.$router.push({ name: "theme" });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "qrCode":
          if (this.$route.name !== "qr") {
            this.$router.push({ name: "qr" });
          } else {
            this.$refs.dialog.$children[0].hide();
          }
          break;
        case "share":
          this.share();
          break;
      }
    },
    edit() {
      this.$router.push({ name: "info-edit" });
    },
    switchGame(event) {
      if (!event.currentTarget.classList.contains("q-fab--opened")) {
        this.$refs.gameSelector.select(1);
      }
    },
    showTextTab(value) {
      this.textTab = value;
    },
    share() {
      this.$refs.shareButton.share();
    },
    openFiles(event) {
      this.nop(event);
      this.$store.dispatch("game/OPEN_FILES", event.dataTransfer.files);
    },
    nop(event) {
      event.stopPropagation();
      event.preventDefault();
    },
  },
  watch: {
    // game() {
    //   this.$store.dispatch("online/LISTEN_CURRENT_GAME");
    // },
    editingTPS() {
      if (this.firstMoveNumber < this.minFirstMoveNumber) {
        this.firstMoveNumber = this.minFirstMoveNumber;
      }
    },
    user(user, oldUser) {
      if (this.$game && this.$game.config.isOnline) {
        if (
          user &&
          (!oldUser || user.uid !== oldUser.uid) &&
          !this.$game.getPlayerFromUID(user.uid) &&
          this.$game.openPlayer
        ) {
          this.$router.push({ name: "join" });
        }
      }
    },
  },
  beforeCreate() {
    // Load online functionality
    // if (process.env.DEV && this.$store.state.online) {
    //   this.$store.unregisterModule("online");
    // }
    // this.$store.registerModule("online", onlineStore);

    // Redirect hash URLs
    if (location.hash.length) {
      const url = location.hash.substr(1);
      location.hash = "";
      this.$router.replace(url);
      location.reload();
      return;
    }

    // Initialize
    // this.$store.dispatch("online/INIT").then(() => {
    //   if (this.gameID) {
    //     // Check that the game is not already open
    //     const index = this.$store.state.game.list.findIndex(
    //       (game) => game.config.id === this.gameID
    //     );
    //     if (index >= 0) {
    //       this.$store.dispatch("game/SELECT_GAME", index);
    //     } else {
    //       // Add online game from URL
    //       this.$store
    //         .dispatch("online/LOAD_GAME", this.gameID)
    //         .then(() => {
    //           this.$router.replace("/");
    //         })
    //         .catch((error) => {
    //           this.$store.dispatch("ui/NOTIFY_ERROR", error);
    //         });
    //     }
    //   }
    // });
  },
  async created() {
    await this.getGame();

    if (!this.gameID) {
      if (!this.games.length) {
        this.$store.dispatch("game/ADD_GAME", {
          ptn: this.$game.toString(),
          name: this.$game.name,
          state: this.$game.minState,
          config: this.$game.config,
        });
      }
    }

    // Listen for dropped files
    if (window.File && window.FileReader && window.FileList && window.Blob) {
      window.addEventListener("drop", this.openFiles, true);
      window.addEventListener("dragover", this.nop, true);
      window.addEventListener("dragleave", this.nop, true);
    }
  },
  beforeDestroy() {
    window.removeEventListener("drop", this.openFiles);
    window.removeEventListener("dragover", this.nop);
    window.removeEventListener("dragleave", this.nop);
  },
};
</script>

<style lang="scss">
#left-drawer,
#right-drawer {
  .q-drawer {
    background: $panel;
    background: var(--q-color-panel);
    .q-drawer__content {
      overflow: hidden;
    }
  }
}

#right-drawer {
  .q-tabs {
    height: $toolbar-min-height;
  }
  .q-tab-panel {
    padding: 0;
  }
}
</style>
